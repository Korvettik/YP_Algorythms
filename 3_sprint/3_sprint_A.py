# https://contest.yandex.ru/contest/23815/run-report/146816847/

# -- ПРИНЦИП РАБОТЫ ---
# Поскольку в условии задачи сказано, что нужно найти элемент в списке,
# да еще и использовать сложность log_n, то единственный подходящим алгоритмом
# является бинарный поиск.
# Сложностью задачи является то, что запускаемая функция не может быть модифицирована
# в плане приема дополнительных аргументов. А также то, что заранее известно,
# что подаваемый список не всегда может быть отсортированным (что является обязательным
# условием для алгоритма бинарного поиска), зато может быть как-бы смещенным кольцевым
# буфером (т.е. отсортирован, но начало и конец, т.е. шов буфера может быть не на границах
# списка, а в его теле).

# Так как мы не можем менять подаваемые аргументы в функцию, т.е. не можем использовать
# рекурсивную конструкцию и передавать индексы левого и правого диапазона бинарного поиска -
# переделывваем его на бесконечный цикл, а индексы задаем перед ним.

# Так как мы не знаем где шов от кольцевого буфера, но знаем вообще как формируется
# такой список, можем его представить + расставить предполагаемое место искомого элемента (К).
# Получится 6 возможных вариантов.

# Цифрами представлены не индексы, а пример некогда упорядоченного, а затем смещенного кольцевого буфера
# Под ними представлены индексы.

# (1)
# 3 4 5 (K) 7 8 index_middle 10 11  Шов 1 2
# 0 1 2  3  4 5      6       7  8      9 10
#
# индекс 0 - index_left
# индекс 11 (не включительно) - index_right

# (2)
# 3 4 5 6 7 8 index_middle 10 (K)  Шов 1 2
# 0 1 2 3 4 5      6       7   8       9 10

# (3)
# 3 4 5 6 7 8 index_middle 10 11  Шов 1 (K)
# 0 1 2 3 4 5      6       7  8       9 10


# (4)
# (K) 11 Шов 1 2 3 index_middle 4 6 7 8 9
#  0  1      2 3 4       5      6 7 8 9 10


# (5)
# 10 11 Шов 1 (K) 3 index_middle 4 6 7 8 9
# 0  1      2  3  4       5      6 7 8 9 10


# (6)
# 10 11 Шов 1 2 3 index_middle 4 6 (K) 8 9
# 0  1      2 3  4       5     6 7  8  9 10

# Теперь нам нужно выбрать только те случаи (и условия к ним), где искомая (К)
# как значение элемента в списке (НЕ ИНДЕКС!) находится слева (все остальные случаи - справа)
# Сюда подойдут варианты (1), (4), (5)



# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
# Поскольку мы используем бинарный поиск, то оперируем отсортированными частями
# исходного списка, где искомый элемент сравнивается с предполагаемым наименьшим элементом,
# допустим левой части.
# Так как мы знаем что список был некогда кольцевым буфером, но был отсортирован,
# но мы не знаем где шов - будем исходить из возможных вариантов где может находиться
# искомый элемент, понимая какие значения могут быть у элементов под индексами середины и левого края.


# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
# Поскольку применен модифицированный метод бинарного поиска,
# а это принцип отбрасывания половины значений при итерациях,
# то сложность определяется как log_n


def broken_search(nums, target) -> int:
    """вернуть индекс элемента, равного k, если такой есть в массиве (нумерация с нуля). Если элемент не найден, функция должна вернуть −1

    сдвинула данные исходной отсортированной последовательности (при этом массив все равно мог остаться отсортированным"""

    # бинарный поиск работает только на отсортированной последовательности

    # чтобы всегда хранить индексы границ
    index_left = 0  # левая граница
    index_right = len(nums)  # правая граница

    while index_left < index_right:  # чтобы не рекурсию использовать, а цикл + это условие выхода (индексы не сравнялись, т.е. что-то в диапазоне есть)
        # промежуток не пуст
        index_middle = (index_left + index_right) // 2  # значение индекса, что расположен примерно в середине рассматриваемого индекс-списка
        #print(f'index_middle {index_middle}')
        #print(f'левая часть {nums[index_left:index_middle+1]}, правая часть {nums[index_middle+1:index_right]}')

        if nums[index_middle] == target:  # нашли
            #print(index_middle)
            return index_middle

        elif (nums[index_middle] <= nums[index_left] <= target
              or target <= nums[index_middle] <= nums[index_left]
              or nums[index_left] <= target <= nums[index_middle]): # искомый элемент следует искать в левой половине
            index_right = index_middle

        else:  # иначе следует искать в правой половине
            index_left = index_middle + 1


    #print(-1)
    return -1 # Значение не найдено, промежуток пуст




def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6



# n = int(input().strip())  # длина массива
# k = int(input().strip())  # искомый элемент
# array = list(map(int, input().strip().split()))  # целые числа, сам массив
# broken_search(array, k)

#test()

