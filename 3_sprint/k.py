# если в предыдущих сортировках мы делили относительно опорноо элемента в грубую клетку на 2 кучи,
# то здесь сортируем попарно самые мелкие группы, а потом их элементы друг с другом,
# т.е. какб-бы наоборот

# Сортировка слиянием работает потому, что она сливает
# УЖЕ ОТСОРТИРОВАННЫЕ части, и процесс слияния не нарушает
# внутренний порядок этих частей - он только выбирает, какой элемент взять следующим.


def merge(arr, lf, mid, rg):
    # Создаем временные массивы для левой и правой частей
    # здесь по 1 элементу сначала
    left_part = arr[lf:mid]
    right_part = arr[mid:rg]

    i = j = 0  # Индексы для left_part и right_part
    k = lf  # Индекс для основного массива

    # Сливаем временные массивы обратно в array[left..right]
    # фактически перезаписываем ячейка по индексам.
    # диапазон исходного массива совпадает с суммой диапазонов ОТСОРТИРОВАННЫХ копий этого-же массива
    # механизм пузырьковой сортировки

    while i < len(left_part) and j < len(right_part):
        if left_part[i] <= right_part[j]:
            arr[k] = left_part[i]
            i += 1
        else:
            arr[k] = right_part[j]
            j += 1
        k += 1

    # Копируем оставшиеся элементы left_part, если есть
    # (они уже отсортированы между собой)

    # когда будем возвращаться обратным ходом (ПЕРЕХОДЯ В БОЛЕЕ КРУПНЫЕ СПИСКИ),
    # они тоже будут отсортированы с другим блоком
    while i < len(left_part):
        arr[k] = left_part[i]
        i += 1
        k += 1

    # Копируем оставшиеся элементы right_part, если есть
    # (они уже отсортированы между собой)

    # когда будем возвращаться обратным ходом (ПЕРЕХОДЯ В БОЛЕЕ КРУПНЫЕ СПИСКИ),
    # они тоже будут отсортированы с другим блоком

    while j < len(right_part):
        arr[k] = right_part[j]
        j += 1
        k += 1

    return arr




def merge_sort(arr, lf, rg):
    # В РЕАЛЬНОСТИ ТУТ ТОЛЬКО ДЕЛИМ НА ПОДМАССИВЫ
    # Базовый случай: если в подмассиве 1 элемент или меньше, он уже отсортирован
    if rg - lf <= 1:
        return

    # Находим середину
    mid = (lf + rg) // 2

    # Рекурсивно сортируем левую и правую части
    # КОГДА ДАЙДЕМ ПО 1 ЭЛЕМЕНТУ ДВУХ самых мелких участков
    # Это будут первые 2 значения в общем списке arr
    # фактически мы получаем нужные нам значения индексов
    merge_sort(arr, lf, mid)
    merge_sort(arr, mid, rg)

    # Сливаем отсортированные части
    # ВОТ ТУТ РЕАЛЬНАЯ СОРТИРОВКА БУДЕТ вот этих 2х первых элементов
    merge(arr, lf, mid, rg)



def test():
	a = [1, 4, 9, 2, 10, 11]
	b = merge(a, 0, 3, 6)
	expected = [1, 2, 4, 9, 10, 11]
	assert b == expected

	c = [1, 4, 2, 10, 1, 2]
	merge_sort(c, 0 , 6)
	expected = [1, 1, 2, 2, 4, 10]
	assert c == expected

if __name__ == '__main__':
    test()