#  https://contest.yandex.ru/contest/23815/run-report/147313331/

# -- ПРИНЦИП РАБОТЫ ---
# В соответствии с условием задачи.
# Логика работы рекурсивной функции повторяет условие задачи. Для смещенного
# отсортированного индекс-списка вызывается эта же функция, рекурсивно.
# Так до тех пор, пока индексы не сойдутся, т.е. индекс-список не закончится.
# Аналогично отрабатывает индекс список для правой группы.
# Сравнение выбранных элементов из списка делаем по сконструированным кортежам, подходящим под условие задачи.

# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
# Массив не копируется, а локально по индексам переставляются его элементы.
# Все операции совершаются над текущим массивом. Операции проводятся над диапазонами индексов.



# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
# Временная сложность, если удачно будут делиться на опорные элементы О(log(N))
# Пространственная сложность О(n), так как работаем с текущим массивом, а сам алгоритм О(1)






# ваша реализация сортировки не может потреблять O(n) дополнительной памяти для промежуточных
# данных (такая модификация быстрой сортировки называется "in-place").

# при сравнении двух участников выше будет идти тот, у которого решено больше задач.
# При равенстве числа решённых задач первым идёт участник с меньшим штрафом.
# Если же и штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.




def quicksort(array, left_global, right_global):
    """
    общая логика

    left_global - индекс изначальный левый
    right_global - индекс изначальный правый
    """

    #print(array, left_global, right_global)

    # базовый случай (индексы пересеклись, а так не должно быть), останавливаемся
    if left_global >= right_global:
        #print(f'left_global >= right_global')
        return

    else:
        pivot = array[(left_global + right_global) // 2]  # берем элемент по ИНДЕКСУ середины (целое число) -  опорный элемент
        # отдельно выносим индексы границ изначальных
        left = left_global  # индекс слева до опорного элемента, для локального сдвига
        right = right_global  # индекс справа от опорного элемента, для локального сдвига

        # вместо рекурсии, просто ползем по существующему списку
        # (для логики слева-направо и справа-налево)
        while left <= right:
            # ползем слева-направо. через цикл узнаем индекс ближайшего элемента к опорному,
            # но БОЛЬШЕ его по значению
            while array[left] < pivot: # пока меньше, все хорошо
                left += 1  # в будущее
            # ползем справа-налево. через цикл узнаем индекс ближайшего элемента к опорному,
            # но МЕНЬШЕ его по значению
            while array[right] > pivot:  # пока больше, все ок
                right -= 1  # в будущее

            # раз дошли до этого места, значит "на месте" меняем значения на индексах местами.
            if left <= right:  # либо это разные индексы и левый слева, а правы справа, либо они друг на друге
                array[left], array[right] = array[right], array[left]
                # сдвигаем дальше. либо условие для выхода из общего цикла
                left += 1
                right -= 1

        # рекурсивный вызов для уменьшенной справа левой части
        quicksort(array, left_global, right)
        # рекурсивный вызов для уменьшенной слева правой части
        quicksort(array, left, right_global)





if __name__ == '__main__':
    n = int(input().strip())  # число участников

    user_list = list()  # список с участниками

    for user in range(n):
        user_name, user_score, user_penalty = input().strip().split()  # читаем параметры пользователя
        # записываем в виде кортежа информацию о каждом пользователе

        # сравниваться будут кортежи, поэтому немного модифицируем порядок
        user_list.append((-int(user_score), int(user_penalty), user_name))  # записываем в виде кортежа информацию о каждом пользователе

    # запуск.
    # индексы общие от самого списка, чтобы было известно откуда начать шагать как-бы к центру
    quicksort(user_list, 0, n - 1)

    # Вывод отсортированного массива.
    for user in user_list:
        print(user[2])
