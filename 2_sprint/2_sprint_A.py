# https://contest.yandex.ru/contest/22781/run-report/146041774/



# -- ПРИНЦИП РАБОТЫ ---
# Поскольку условием алгоритма должен быть кольцевой буфер, он и выбран.
# Я представил его в виде списка с ограниченным количеством ячеек.
# Если проиндексировать этот список, то будет, к примеру 01...8
# Представим, что ячейка с индексом 1 - это голова. За ней в сторону индексов 2,3 ... 8 будут ячейки самого буфера.
# Но хвостом буфера будет ячейка с индексом 0. Т.е. Представим, что ячейка 8 далее как-бы замыкается индексом 0. А после индекса 0 снова идет голова - индекс 1
# По умолчанию все ячейки заполним None
#
# push_back()
# Под этим понимаем, что нужно вставить новый элемент за хвостом, т.е. еще дальше.
# В решении мы сначала определяем индекс следующей за хвостом ячейки. Для этого не просто индекс увеличиваем на +1 (т.к. двигаемся по индексам направо),
# а берем остаток от деления максимально возможного индекса, чтобы получить как бы переход на новый круг, если такое потребуется,
# и индекс будет соответствовать возможным индексам. Затем записываем новое значение в этот новых хвост. Увеличиваем счетчик занятых ячеек.

# push_front()
# Под этим понимаем, что нужно вставить элемент в ячеку, которая стоит до ячейки. являющейся головой.
# Аналогично мы определяем ее индекс. с учетом возможного перехода на новый круг (находим остаток от деления)
# записываем в нее значение. Увеличиваем счетчик занятых ячеек.

# pop_front()
# Под этим понимаем. что нужно ввывести и вырезать текущую голову.
# А новую голову переназначить на ту ячейку, что следует после нее. т.е. в сторону хвоста.
# Берем значение ячейки текущей головы и выводим его. Перезаписываем в него None,
# а затем смещаем голову далее вправо +1 по списку, также с учетом возможного прехода индекса на второй круг.

# pop_back()
# Здесь понимаем, что нужно вывести и вырезать значение ячейки текущего хвоста. Поступаем аналогично, только новый хвост сдвигаем влево -1 в сторону головы.


# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
# 1) При движении по индексам влево - вправо все понятно, если представить что список линейный.
# 2) чтобы индексы не уползали за пределы дозволенных индексов 01...8 к примеру,
# то применяется корректировка вычислений сдвига --- берем остаток от деления на максимальный возможный индекс 8 к примеру



# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
# Сложность алгоритма О(1). т.к. одна процедура самого действия фактически выполняется 1 раз.
# Чем больше таких процедур, тем больше времени потребуется, но сложность каждой процедуры не меняется
# Пространственная сложность определяется фактически количеством введеной информации - т.е. количеством требуемых итераций обращения к алгоритму. Т.е. О(n)



class Queue:
    def __str__(self):
        """класс очередь на кольцевом буфере"""

    def __init__(self, m):
        self.queue = [None] * m   # элементы очереди --- ОБЫЧНЫЙ СПИСОК
        self.head = 1  # индекс, по которому нужно извлекать элемент, если очередь не пустая;
        self.tail = 0  # индекс, по которому нужно добавлять элемент, если в очереди есть место;
        self.max_m = m  # максимально возможное количество элементов в очереди
        self.size = 0  # размер очереди


    def is_empty(self):
        return self.size == 0


    # ------------------------------------------
    # добавить элемент в конец дека. Если в деке уже находится максимальное число элементов,
    # вывести «error».
    # Для успешных запросов push_back(x) и push_front(x) ничего выводить не надо.
    def push_back(self, value):
        if self.size != self.max_m:
            self.tail = (self.tail + 1) % self.max_m
            self.queue[self.tail] = value
            self.size += 1
        else:
            print('error')




    # добавить элемент в начало дека. Если в деке уже находится максимальное число элементов
    # вывести «error».
    def push_front(self, value):
        if self.size != self.max_m:
            self.head = (self.head - 1) % self.max_m
            self.queue[self.head] = value
            self.size += 1
        else:
            print('error')


    # вывести первый элемент дека и удалить его. Если дек был пуст, то вывести «error».
    def pop_front(self):
        if self.is_empty():
            print('error')
        else:
            x = self.queue[self.head]
            self.queue[self.head] = None
            self.head = (self.head + 1) % self.max_m
            self.size -= 1
            print(x)


    # вывести последний  элемент дека и удалить его. Если дек был пуст, то вывести «error». ====================
    def pop_back(self):
        if self.is_empty():
            print('error')
        else:
            x = self.queue[self.tail]
            self.queue[self.tail] = None
            self.tail = (self.tail - 1) % self.max_m
            self.size -= 1
            print(x)


if __name__ == '__main__':
    n = int(input())  # количество команд
    m = int(input())  # максимальный размер дека

    queue = Queue(m)

    for _ in range(n):
        command = input().strip().split()

        if command[0] == 'push_back':
            #print(command)
            queue.push_back(command[1])
            #print(queue.queue)
            #print()
        elif command[0] == 'push_front':
            #print(command)
            queue.push_front(command[1])
            #print(queue.queue)
            #print()
        elif command[0] == 'pop_front':
            #print(command)
            queue.pop_front()
            #print(queue.queue)
            #print()
        elif command[0] == 'pop_back':
            #print(command)
            queue.pop_back()
            #print(queue.queue)
            #print()

    # print(queue.queue)


