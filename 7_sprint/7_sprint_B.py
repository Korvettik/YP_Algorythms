#


# -- ПРИНЦИП РАБОТЫ ---
"""
1) Получаем все данные
2) Вычисляем общую сумму по очкам. Если число нечетное, то разделить на 2 равные кучки сумм-очков не получится.
Поэтому это случай, который сразу проверяем и если да, то возвращаем отрицательный результат.

3) Если все-таки возможно сделать 2 одинаковый по суммам кучки очков, то тут нужно проверить, возможно ли их вообще
сложить из имеющихся значений очков, разделив из на 2 кучки.

4) Вычисляем половинку общей суммы очков -- это будет явная цель, которую нужно подобрать
из существующих очков (пускай это число 5).

5) Создаем список из флагов по размеру этой половинки +1 (для того, чтобы использовать индексы включительно).
Индекс в массиве - это текущая набегаемая сумма (как бы из единичек складывается).
А значение (False/True) - сообщает статус, можно ли набрать эту сумму из существующих значений очков

False  False  False  False  False  False
  0      1      2      3      4      5    ---- индекс-сумма

Число равное 0, т.е. если бы сумма была 0 всегда можно получить, для этого очки не нужны. Поэтому значение ставим сразу в True

 True  False  False  False  False  False
  0      1      2      3      4      5

6) Главным внешним циклом перебираем слева-направо ЗНАЧЕНИЯ полученных изначальных очков.
Внутренним циклом идем в обратном порядке по ИНДЕКСАМ-суммам справа-налево от общей суммы (10) до половинки (5)


"""






# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Используем метод динамического программирования.

"""


# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""

"""


def find_separate(n, scores):
    #print(n, scores, sep='\n')

    total_summ = sum(scores)
    #print(total_summ)

    # если общая сумма очков нечетная, то и разбить ее не получится точно
    if total_summ % 2 != 0:
        return False

    else:
        # вычисляем половинку - цель для комбинаций
        target = total_summ // 2  # чтобы int, а не float

        target_statistic = [False] * (target + 1)
        target_statistic[0] = True

        for score in scores:
            # идем в обратном порядке, чтобы избежать повторного использования одного элемента
            for j in range(target, score - 1, -1):
                if target_statistic[j - score]:
                    target_statistic[j] = True

        return target_statistic[target]







if __name__ == "__main__":
    n = int(input().strip())   # количество выигранных партий
    scores = list(map(int, input().strip().split()))  # список заработанных очков по каждой партии
    print(find_separate(n, scores))