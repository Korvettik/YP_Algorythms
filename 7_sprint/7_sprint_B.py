#


# -- ПРИНЦИП РАБОТЫ ---
"""
1)
Получаем все данные
2)
Вычисляем общую сумму по очкам. Если число нечетное, то разделить на 2 равные кучки сумм-очков не получится.
Поэтому это случай, который сразу проверяем и если да, то возвращаем отрицательный результат.

3)
Если все-таки возможно сделать 2 одинаковый по суммам кучки очков, то тут нужно проверить, возможно ли их вообще
сложить из имеющихся значений очков, разделив из на 2 кучки.

4)
Вычисляем половинку общей суммы очков -- это будет явная цель, которую нужно подобрать
из существующих очков (пускай это число 5).

5)
Создаем список из флагов по размеру этой половинки +1 (для того, чтобы использовать индексы включительно).
Индекс в массиве - это текущая набегаемая сумма (как бы из единичек складывается).

А значение (False/True) - сообщает статус, можно ли набрать эту сумму из существующих И ОБРАБОТАННЫХ значений очков

False  False  False  False  False  False
  .0     .1     .2    .3      .4    .5    ---- индекс-сумма

Число равное 0, т.е. если бы сумма была 0 всегда можно получить, для этого очки не нужны. Поэтому значение ставим сразу в True

 True  False  False  False  False  False
  .0    .1     .2     .3      .4    .5


6)
== Внешний цикл ==
Берем значения очков по очереди.
[ _5  _3  _1  _1 ] --- общая сумма 10,

цель = половинка значит ц5

== Внутренний цикл ==
[ '5  '4  '3  '2  '1 ]  --- набегаемое значение цели 5 из чисел +1+1..., развернуто

6.1)
От цели (ц5) до текущего значения очков (_5) получаем список индексов для просмотра --- ['5]
Смотрим значение в списке флагов по каждому из этих индексов ['5 - _5] = .0 и если там True,
то и флаг [.5] тоже будет True
(Т.е. чтобы получить _5 и у нас есть .0, нам нужна '5 и такой индекс есть, это .5)

 True  False  False  False  False   True
  (.0)  .1     .2     .3     .4     (.5)

6.2)
От цели (ц5) до текущего значения очков (_3) получаем список индексов для просмотра --- ['5 '4 '3]
Смотрим значение в списке флагов по каждому из этих индексов ['5 - _3] = .2 там False, ничего не меняем
Смотрим значение в списке флагов по каждому из этих индексов ['4 - _3] = .1 там False, ничего не меняем
Смотрим значение в списке флагов по каждому из этих индексов ['3 - _3] = .0 и если там True,
то и флаг [.3] тоже будет True
(Т.е. чтобы получить _5 и у нас есть .3, нам нужна '5 и такой индекс есть, это .5)

 True  False  False  True   False   True
  (.0)  .1     .2     .3     .4     (.5)



7)
В конце концов возвращаем значение флага под индексом размера половинки.

"""






# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Используем метод динамического программирования.

"""


# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность - O(n * target)   Когда нужно обработать все значения, и проделывать это с половиной от суммы их значений
Пространственная сложность - 

"""


def find_separate(n, scores):
    #print(n, scores, sep='\n')

    total_summ = sum(scores)
    #print(total_summ)

    # если общая сумма очков нечетная, то и разбить ее не получится точно
    if total_summ % 2 != 0:
        return False

    else:
        # вычисляем половинку - цель для комбинаций
        target = total_summ // 2  # чтобы int, а не float

        target_statistic = [False] * (target + 1)
        target_statistic[0] = True

        # основная логика
        for score in scores:
            for j in range(target, score - 1, -1):
                if target_statistic[j - score]:
                    target_statistic[j] = True

        return target_statistic[target]







if __name__ == "__main__":
    n = int(input().strip())   # количество выигранных партий
    scores = list(map(int, input().strip().split()))  # список заработанных очков по каждой партии
    print(find_separate(n, scores))