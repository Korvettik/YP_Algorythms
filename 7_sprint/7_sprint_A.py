#


# -- ПРИНЦИП РАБОТЫ ---
"""
1) получаем исходные данные. 2 слова. Первую строку нужно превратить во вторую с минимальным количеством операций.
Задачу будем решать методом динамического программирования.
2) Строим матрицу (matrix), список списков по количеству символов подаваемого слова и количеству символов результирующего слова.
Заполняем каёмку (по горизонтали и вертикали с края) порядковыми номерами букв по существующим словам. Остальные ячейки матрицы ставим в нули.

       Б  О  Б  И  К  (t)
    0  1  2  3  4  5   - j   нумера совпадают с логикой, что каждая ячейка (от t) равна накопительному числу изменений, если бы второе слово (s) было пустотой
 Б  1  0  0  0  0  0
 О  2  0  0  0  0  0
 Б  3  0  0  0  0  0
(s)
 '
 i

3) Внутри ячейки matrix[i][j] храним число, равное минимальному количеству операций,
чтобы превратить текущие на данный момент i символов строки s в текущие на данный момент j символов строки t.

4) Теперь нужно заполнить все нулевые ячейки. Для этого пройдемся по каждой matrix[i][j],
сравним буквы по их координатам в подаваемых словах и впишем в ячейку накопительное число требуемых изменений.


5) Сравниваем символы в строках.
Идем по первой строке.
Если совпадают буквы подаваемого и требуемого слов s[i-1] == t[j-1], то никаких операций-манипуляций делать не нужно,
поэтому в матрицу записываем текущее значение из ячейки по диагонали сверху сзади matrix[i - 1][j - 1]
Диагональ от текущей ячейки всегда есть накопительная величина, но уже неизменяемое число операций)

Б == Б , значит 0 операций изменений, значит в ячейке будет 0

Если НЕ совпадают буквы подаваемого и требуемого слов s[i-1] != t[j-1], то посмотрим 3 ее соседние ячейки
    matrix[i-1][j-1]  matrix[i-1][j]
    matrix[i][j-1]    matrix[i][j] --- фокус на конкретной этой

и запишем в фокусированную ячейку минимальное число из 3х полученных значений на данный момент + 1 так как это новое изменение.

БО != Б, значит 1 операция изменений, значит в ячейке будет 1

       Б    О   Б  И  К  (t)
    0  1'   2'  3  4  5   - j
 Б  1  0'  (1)  2  3  4
 О  2  0    0   0  0  0
 Б  3  0    0   0  0  0
(s)
 '
 i

БОБ != Б, уже 2 изменения, поэтому 2

       Б  О   Б   И  К  (t)
    0  1  2'  3'  4  5   - j
 Б  1  0  1' (2)  3  4
 О  2  0  0   0   0  0
 Б  3  0  0   0   0  0
(s)
 '
 i

6) Выведем на экран значение самой нижней правой матрицы --- там будет минимальное накопительное число изменений в разнице двух слов.


"""




# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --



# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --



def find_distance(s, t):
    len_s = len(s)
    len_t = len(t)
    # print(len_s, len_t)

    matrix = [[0] * (len_t + 1) for _ in range(len_s + 1)]  # список списков, создаем матрицу по длинам введенных строк и заполняем нулями

    # == каёмочка ==
    # заполняем матрицу по вертикали (левый столбец как-бы)
    for i in range(len_s + 1):
        matrix[i][0] = i
    # print(matrix)
    # заполняем по горизонтали (верхняя линия)
    for j in range(len_t + 1):
        matrix[0][j] = j
    # print(matrix)

    # проходимся по пустым ячейкам, анализируем их соседей, принимаем решение
    for i in range(1, len_s + 1):
        for j in range(1, len_t + 1):
            # символы равны
            if s[i - 1] == t[j - 1]:
                matrix[i][j] = matrix[i - 1][j - 1]  # берем значение от ее диагонального значения
            else:
                matrix[i][j] = 1 + min(
                    matrix[i - 1][j],  # удаление
                    matrix[i][j - 1],  # вставка
                    matrix[i - 1][j - 1]  # замена
                )

    return matrix[len_s][len_t]


if __name__ == "__main__":
    s = input().strip()
    t = input().strip()
    print(find_distance(s, t))