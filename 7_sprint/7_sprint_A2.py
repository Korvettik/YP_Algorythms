# https://contest.yandex.ru/contest/25597/run-report/155399984/


# -- ПРИНЦИП РАБОТЫ ---
"""
1) получаем исходные данные. 2 слова. Первую строку нужно превратить во вторую с минимальным количеством операций.
Задачу будем решать методом динамического программирования.

2) Для экономии памяти определяем, какая строка длиннее. Если вторая строка (t) длиннее первой (s), меняем их местами.

3) Вместо полной матрицы n×m

       Б  О  Б  И  К  (t)
    0  1  2  3  4  5   - j
 Б  1  0  0  0  0  0
 О  2  0  0  0  0  0
 Б  3  0  0  0  0  0
(s)
 '
 i

используем только две строки (списки)
old_row ----- предыдущая строка матрицы (соответствует i-1 символам строки s)
current_row ----- текущая строка матрицы (соответствует i символам строки s)

длина каждого списка равна len(t) + 1

4) Вначале создаем old_row как каемку по горизонтали: [0, 1, 2, ..., len(t)]
А current_row заполняем нулями. Это будет, когда строка s пустая, и нам нужно вставить все символы из t.

s = "БОБ", t = "БОБИК"
После обмена (t длиннее) их меняем местами s = "БОБИК", t = "БОБ"

old_row создаем: [0, 1, 2, 3]
Это соответствует матрице:

    ""  Б   О   Б   (t)
""  0   1   2   3

5) Теперь обрабатываем каждый символ строки s:
Устанавливаем current_row[0] = i (вертикальная каемка. число есть сколько символов надо удалить из s)

Для каждого символа t[j-1] в строке t:
    Если символы совпадают (s[i-1] == t[j-1]), то
       current_row[j] = old_row[j-1] (берем значение по диагонали от предыдущей строки)

    А если символы не совпадают, то:
       current_row[j] = 1 + наименьшее из
           old_row[j],      # Удаление символа из s
           current_row[j-1],    # Вставка символа в s
           old_row[j-1]     # Замена символа в s


6) После обработки всех символов t для текущего символа s, строки меняются местами:

7) в конце, после прохода всех символов s, ответ будет в последнем элементе old_row.
Это соответствует нижней правой ячейке полной матрицы.
"""



# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
В соответствии с условием задачи применен алгоритм вычисления расстояние Левенштейна, используем динамическое программирование
"""


# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность - O(n*m), т.к. мы проходимся по всем буквам в двух списках, по матрице
Пространственная сложность - O(min(n, m)), т.к. мы храним только две строки матрицы (текущую и предыдущую), 
и мы всегда работаем с более короткой строкой как со столбцом для экономии памяти
"""


def find_distance(s, t):
    # экономим память -  если t короче s, меняем их местами - это позволяет использовать меньше памяти при построении матрицы
    if len(t) > len(s):
        s, t = t, s

    len_s = len(s)
    len_t = len(t)
    # print(len_s, len_t)


    # предыдущая строка матрицы (i-1)
    old_row = list(range(len_t + 1))
    # текущая строка матрицы (i)
    current_row = [0] * (len_t + 1)

    # по строке s (как длинной)
    for i in range(1, len_s + 1):
        current_row[0] = i  # значение, сколько надо удалить символов из s

        # по строке t (как короткой)
        for j in range(1, len_t + 1):
            # символы равны
            if s[i - 1] == t[j - 1]:
                current_row[j] = old_row[j - 1]  # берем значение от ее диагонального значения
            else:
                current_row[j] = 1 + min(
                    old_row[j],  # удаление (из предыдущей строки, тот-же столбец)
                    current_row[j - 1],  # вставка (из текущей строки, берем предыдущий стоблец)
                    old_row[j - 1]  # замена (диагональ из предыдущей строки)
                )

        # делаем ее предыдущей для следующей итерации (меняем местами)
        old_row, current_row = current_row, old_row

    return old_row[len_t]


if __name__ == "__main__":
    s = input().strip()
    t = input().strip()
    print(find_distance(s, t))