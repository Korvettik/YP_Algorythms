# -- ПРИНЦИП РАБОТЫ ---
"""

"""

# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""

"""

# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""

"""


import heapq

def make_reach_net():
    # (1) --- получаем данные и строим смежный список ---

    # n - количество вершин
    # m - количество ребер
    n, m = tuple(map(int, input().strip().split()))
    #print(n, m)

    # строим список смежности
    graph = [[] for _ in range(n)]  # список пустых списков
    #print(graph)

    # заполняем его полученными данными
    # В каждой из следующих m строк заданы рёбра в виде троек чисел u,v,w.
    # u и v — вершины, которые соединяет это ребро.
    # w — его вес
    for _ in range(m):
        u,v,w = tuple(map(int, input().strip().split()))

        # игнорируем такие ребра, так как они бесполезны для остовного дерева (защита от петель)
        if u == v:
            continue

        # 1) индексы вершин в списке с нуля, но подаются вершины с 1 (по условию)
        # поэтому переводим номера вершин в индексы списка (-1) и в таком виде записываем

        # 2) в индекс-вершину (являющуюся списком) добавляем в виде кортежей информацию о ребрах
        # (вес ребра, в какую вершину ведет), причем сразу добавляем и обратное ребро.
        # [[(5, 1), (6, 2)], [(5, 0), (8, 3)], [(6, 0), (3, 3)], [(8, 1), (3, 2)]]
        graph[u-1].append((w, v-1))
        graph[v-1].append((w, u-1))
    # print(graph)


    # (2) --- для графа с одной вершиной нельзя построить ребер, значит вес 0
    if n <= 1:
        print(0)
        return

    # алгоритм Прима
    # (3) --- создаем кучу и задаем ей текущий максимум ---
    visited = [False] * n  # создаем список индекс-вершин со статусами False - не посещен, True - посещен
    # [False, False, False, False]
    max_heap = []  # список, максимальная куча через отрицательные числа (вес ребер), чтобы получать максимальный

    # (3.1) --- начинаем с первой вершины, индекс 0
    visited[0] = True  # вошли, меняем статус
    for weight, neighbor in graph[0]:  # просматриваем все ребра (вес, в какую вершину) и добавляем их
        if not visited[neighbor]:  # смотрим в списке посещенных указанный нам индекс-вершину, и если ее не посещали, то
            heapq.heappush(max_heap, (-weight, neighbor))  # добавляем в кучу данное ребро. Вес ставим отрицательным.
            # [(-вес, куда), (-вес, куда)]

    total_weight = 0  # общий вес, т.к. пока только 1 вершина кучи
    vertices_in_mst = 1  # счетчик посещенных вершин

    # пока в куче есть ребра и пока не все вершины посещены
    while max_heap and vertices_in_mst < n:

        # (3.2) --- берем максимальное ребро из кучи
        neg_weight, vertex = heapq.heappop(max_heap)  #  берется последний кортеж в списке, а он в куче отсортирован. (по модулю самый большой вес)

        if visited[vertex]:  # если вершина, куда ведет максимальный вес, уже посещалась, пропускаем ее
            continue

        # кортеж ребра и ведущий к вершине не посещался

        # (3.3) --- суммируем данные к этой вершине
        visited[vertex] = True  # отмечаем вершину ребра посещенной
        weight = -neg_weight  # переводим вес ребра в положительное значение
        total_weight += weight  # копим общий вес между вершиной и вершиной с ребром к вершине с макисмальным весом
        vertices_in_mst += 1  # считаем эту вершину

        # (3.4) --- добавляем в общую кучу только рёбра к непосещённым вершинам от текущей вершины с ребром максимального веса
        for w, neighbor in graph[vertex]:
            if not visited[neighbor]:
                heapq.heappush(max_heap, (-w, neighbor))

    # (4) --- проверка связности (если все вершины посетим и построим остовное дерево, значит граф связный)
    if vertices_in_mst == n:
        print(total_weight)
    else:
        print("Oops! I did it again")



if __name__ == "__main__":
    make_reach_net()