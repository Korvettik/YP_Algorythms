# https://contest.yandex.ru/contest/25070/run-report/153323630/

# -- ПРИНЦИП РАБОТЫ ---
"""
Принцип работы основан на алгоритме Прима и кучи в качестве выбора ребра с максимальным весом.
(1) Получаем все данные и строим смежный список. Для каждого индекса-вершины добавляем группу кортежей, которые ведут к ней или от нее с указанием веса ребра.
(2) Создаем список со статусами посещения вершин. Индекс флага есть индекс вершины в смежном списке.
Создаем объект кучи на базе пустого списка.
(3) Берем любую вершину из смежного списка, допустим первую, под индексом 0. Смотрим на ее ребра. Если вершина конкретного ребра, куда оно ведет еще не посещалась
(не отмечена флагом в списке посещения вершин), то добавляем ее в кучу. Так со всеми ребрами данной вершины. Итого у нас есть ребра первой вершины,
которые ведут в еще непосещенные вершины.
(4) Задаем общий вес как 0,т.к. мы еще никуда не пошли, а стоим на первой вершине. В списке посещенный вершин отмечаем ее как посещенную.
Отмечаем счетчик посещенных вершин (если он будет равен количеству всех вершин, значит мы их все обошли и дерево будет связным).
(5) Заходим в цикл с условиями, что в куче есть элементы (пока только те что есть) и что счетчик посещенных вершин меньше общего числа вершин.
Внутри цикла из кучи вырезаем элемент с максимальным весом ребра (кортеж). Т.е. это последний элемент, автосортировка отрицательных чисел.
Смотрим у данного ребра вершину куда оно ведет и сравниваем со спископ посещенных вершин. Если уже посещали - пропускаем.
(6) Если не посещали, то отмечаем вершину, куда идет ребро. как посещенную, добавляем в общий список весов вес этого ребра (а он максимальный из исходного ребра),
увеличиваем счетчик посещенных вершин и добавляем все ребра вот этой новой вершины в нашу текущую кучу (с проверками, что куда они ведут мы там не были).
(7) Когда все ребра закончатся и будут посещены все вершины. выйдем из цикла. И подведем итоги. Если все посетили - выводим общий вес максимальных весов ребер,
если нет - сообщение об ошибке согласно заданию.
"""

# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Используется логика аллгоритма Прина, используется сортировка кучей по максимальному весу ребра, 
убраны варианты с зацикливанием, обрабатывается случай с единственной вершиной, проверяется связность.
"""

# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность - поскольку используется алгоритм Прина, то о обработка данных по ребрам O(m), 
обработка вставки и удаления по вершинам из кучи O(log n). Общее получится как O(m log n).

Пространственная сложность O(n+m) для хранения графа и O(n) для кучи
"""


import heapq

def make_reach_net():
    # (1) --- получаем данные и строим смежный список ---

    # n - количество вершин
    # m - количество ребер
    n, m = tuple(map(int, input().strip().split()))
    #print(n, m)

    # строим список смежности
    graph = [[] for _ in range(n)]  # список пустых списков
    #print(graph)

    # заполняем его полученными данными
    # В каждой из следующих m строк заданы рёбра в виде троек чисел u,v,w.
    # u и v — вершины, которые соединяет это ребро.
    # w — его вес
    for _ in range(m):
        u,v,w = tuple(map(int, input().strip().split()))

        # игнорируем такие ребра, так как они бесполезны для остовного дерева (защита от петель)
        if u == v:
            continue

        # 1) индексы вершин в списке с нуля, но подаются вершины с 1 (по условию)
        # поэтому переводим номера вершин в индексы списка (-1) и в таком виде записываем

        # 2) в индекс-вершину (являющуюся списком) добавляем в виде кортежей информацию о ребрах
        # (вес ребра, в какую вершину ведет), причем сразу добавляем и обратное ребро.
        # [[(5, 1), (6, 2)], [(5, 0), (8, 3)], [(6, 0), (3, 3)], [(8, 1), (3, 2)]]
        graph[u-1].append((w, v-1))
        graph[v-1].append((w, u-1))
    # print(graph)


    # (2) --- для графа с одной вершиной нельзя построить ребер, значит вес 0
    if n <= 1:
        print(0)
        return

    # алгоритм Прима
    # (3) --- создаем кучу и задаем ей текущий максимум ---
    visited = [False] * n  # создаем список индекс-вершин со статусами False - не посещен, True - посещен
    # [False, False, False, False]
    max_heap = []  # список, максимальная куча через отрицательные числа (вес ребер), чтобы получать максимальный

    # (3.1) --- начинаем с первой вершины, индекс 0
    visited[0] = True  # вошли, меняем статус
    for weight, neighbor in graph[0]:  # просматриваем все ребра (вес, в какую вершину) и добавляем их
        if not visited[neighbor]:  # смотрим в списке посещенных указанный нам индекс-вершину, и если ее не посещали, то
            heapq.heappush(max_heap, (-weight, neighbor))  # добавляем в кучу данное ребро. Вес ставим отрицательным.
            # [(-вес, куда), (-вес, куда)]

    total_weight = 0  # общий вес, т.к. пока только 1 вершина кучи
    vertices_in_mst = 1  # счетчик посещенных вершин

    # пока в куче есть ребра и пока не все вершины посещены
    while max_heap and vertices_in_mst < n:

        # (3.2) --- берем максимальное ребро из кучи
        neg_weight, vertex = heapq.heappop(max_heap)  #  берется последний кортеж в списке, а он в куче отсортирован. (по модулю самый большой вес)

        if visited[vertex]:  # если вершина, куда ведет максимальный вес, уже посещалась, пропускаем ее
            continue

        # кортеж ребра и ведущий к вершине не посещался

        # (3.3) --- суммируем данные к этой вершине
        visited[vertex] = True  # отмечаем вершину ребра посещенной
        weight = -neg_weight  # переводим вес ребра в положительное значение
        total_weight += weight  # копим общий вес между вершиной и вершиной с ребром к вершине с макисмальным весом
        vertices_in_mst += 1  # считаем эту вершину

        # (3.4) --- добавляем в общую кучу только рёбра к непосещённым вершинам от текущей вершины с ребром максимального веса
        for w, neighbor in graph[vertex]:
            if not visited[neighbor]:
                heapq.heappush(max_heap, (-w, neighbor))

    # (4) --- проверка связности (если все вершины посетим и построим остовное дерево, значит граф связный)
    if vertices_in_mst == n:
        print(total_weight)
    else:
        print("Oops! I did it again")



if __name__ == "__main__":
    make_reach_net()