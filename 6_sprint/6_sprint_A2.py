#  https://contest.yandex.ru/contest/25070/run-report/154136641/

# -- ПРИНЦИП РАБОТЫ ---
"""
Принцип работы основан на алгоритме Прима и кучи в качестве выбора ребра с максимальным весом.
(1) Получаем все данные и строим смежный список. Для каждого индекса-вершины добавляем группу кортежей, которые ведут к ней или от нее с указанием веса ребра.
(2) Создаем список со статусами посещения вершин. Индекс флага есть индекс вершины в смежном списке.
Создаем объект кучи на базе пустого списка.
(3) Берем любую вершину из смежного списка, допустим первую, под индексом 0. Смотрим на ее ребра. Если вершина конкретного ребра, куда оно ведет еще не посещалась
(не отмечена флагом в списке посещения вершин), то добавляем ее в кучу. Так со всеми ребрами данной вершины. Итого у нас есть ребра первой вершины,
которые ведут в еще непосещенные вершины.
(4) Задаем общий вес как 0,т.к. мы еще никуда не пошли, а стоим на первой вершине. В списке посещенный вершин отмечаем ее как посещенную.
Отмечаем счетчик посещенных вершин (если он будет равен количеству всех вершин, значит мы их все обошли и дерево будет связным).
(5) Заходим в цикл с условиями, что в куче есть элементы (пока только те что есть) и что счетчик посещенных вершин меньше общего числа вершин.
Внутри цикла из кучи вырезаем элемент с максимальным весом ребра (кортеж). Т.е. это последний элемент, автосортировка отрицательных чисел.
Смотрим у данного ребра вершину куда оно ведет и сравниваем со спископ посещенных вершин. Если уже посещали - пропускаем.
(6) Если не посещали, то отмечаем вершину, куда идет ребро. как посещенную, добавляем в общий список весов вес этого ребра (а он максимальный из исходного ребра),
увеличиваем счетчик посещенных вершин и добавляем все ребра вот этой новой вершины в нашу текущую кучу (с проверками, что куда они ведут мы там не были).
(7) Когда все ребра закончатся и будут посещены все вершины. выйдем из цикла. И подведем итоги. Если все посетили - выводим общий вес максимальных весов ребер,
если нет - сообщение об ошибке согласно заданию.
"""

# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Используется логика аллгоритма Прина, используется сортировка кучей по максимальному весу ребра, 
убраны варианты с зацикливанием, обрабатывается случай с единственной вершиной, проверяется связность.
"""

# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность
a) поскольку используется алгоритм Прина, то о обработка данных по ребрам O(m),
б) обработка вставки и удаления по ребрам O(log m) - размер кучи фактически определяется количеством ребер, указывающих на непосещенные вершины
Общее получится как O(m log m).

Пространственная сложность 
O(n+m) для хранения графа и O(n) для кучи
"""


import heapq

def make_reach_net():
    # (1) --- получаем данные и строим смежный список ---
    n, m = tuple(map(int, input().strip().split()))

    # строим список смежности
    graph = [[] for _ in range(n)]

    # В каждой из следующих m строк заданы рёбра в виде троек чисел u,v,w.
    # u и v — вершины, которые соединяет это ребро.
    # w — его вес
    for _ in range(m):
        u,v,w = map(int, input().strip().split())

        # защита от петель
        if u == v:
            continue

        # 1) вес ребра, в какую вершину ведет, причем сразу добавляем и обратное ребро.
        # [[(5, 1), (6, 2)], [(5, 0), (8, 3)], [(6, 0), (3, 3)], [(8, 1), (3, 2)]]
        graph[u-1].append((w, v-1))
        graph[v-1].append((w, u-1))


    # (2) --- для графа с одной вершиной нельзя построить ребер, значит вес 0
    if n <= 1:
        print(0)
        return


    def add_vertexes(vertex, visited, graph, heap):
        "внутренняя вспомогательная функция для добавления вершин"
        for weight, neighbor in graph[vertex]:
            if not visited[neighbor]:
                heapq.heappush(heap, (-weight, neighbor))



    # алгоритм Прима
    # (3) --- создаем кучу и задаем ей текущий максимум ---
    visited = [False] * n
    # [False, False, False, False]
    max_heap = []

    # (3.1) --- начинаем с первой вершины, индекс 0
    visited[0] = True
    add_vertexes(0, visited, graph, max_heap)

    total_weight = 0  # общий вес, т.к. пока только 1 вершина кучи
    vertices_in_mst = 1  # счетчик посещенных вершин

    while max_heap and vertices_in_mst < n:

        # (3.2) --- берем максимальное ребро из кучи
        neg_weight, vertex = heapq.heappop(max_heap)

        if visited[vertex]:
            continue

        # кортеж ребра и ведущий к вершине не посещался

        # (3.3) --- суммируем данные к этой вершине
        visited[vertex] = True
        weight = -neg_weight
        total_weight += weight
        vertices_in_mst += 1

        # (3.4) --- добавляем в общую кучу только рёбра к непосещённым вершинам от текущей вершины с ребром максимального веса
        add_vertexes(vertex, visited, graph, max_heap)

    # (4) --- проверка связности (если все вершины посетим и построим остовное дерево, значит граф связный)
    if vertices_in_mst == n:
        print(total_weight)
    else:
        print("Oops! I did it again")





if __name__ == "__main__":
    make_reach_net()