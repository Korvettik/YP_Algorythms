# https://contest.yandex.ru/contest/25070/run-report/153338991/

# -- ПРИНЦИП РАБОТЫ ---
"""
1) Получаем данные. Карту земли и воды представляем в виде списка списков - матрицы, сетки. Задаем начальные нулевые
значения искомых величин. Сразу создаем список кортежей  - возможных шагов перемещения курсора в рамках одного острова (вверх, вниз, влево, вправо)
2) Основным циклом итеративно идем по всем ячейкам сверху вниз, слева направо. Если ячейка является землей - это представляет для нас интерес. Ячейки с водой пропускаются.
3) Если ячейка с землей, то увеличиваем счетчик количества островов, т.к. это первый остров, что нам встретился.
Теперь нужно понять его размеры и замерить их. Для этого создадим очередь координат, начиная с текущей точки земли. Циклично будем идти по данной очереди выдергивая
и кладя в нее координаты смежных с данной точкой точек земли, если таковые находятся.
Причем когда очередь опустеет, значит мы обошли все смежные точки, к которым можно было попасть из исходной, руководствуясь координатами зон свободы.
4) Обходя точки одного острова мы их помечали в общей матрице как исследованые, т.е. водой - чтобы выйдя из этого цикла, порожденного первой точкой,
перейти к новой точке основного итеративного цикла, которая также может оказаться землей, а значит новым островом. С ним нужно проделать такую-же операцию изучения.
5) Дойдя до последней ячейки матрицы, выходим из нее и выводим результат. Количество островов есть количество групп точек, которые между
собой являются смежными, но никак не связаны друг с другом. Размер наибольшей группы обновляется.
"""

# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Реализуется проход по всем ячейкам, которые представляют интерес - # земля. Ячейки с водой . игнорируются. Этим символом также 
помечаются те ячейки, что мы уже посещали.
Вокруг каждой ячейки исследуется ее окружение через дек (очередь) координат.
"""

# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность - O(n * m), так как нужно посетить каждую ячейку матрицы-сетки.
Пространственная сложность - O(n * m), так как нужно хранить значения каждой ячейки.
"""



from collections import deque

def find_islads():
    # (1) --- ввод данных
    n, m = map(int, input().split())  # размеры земли (матрица, сетка)
    # print(n, m)
    grid_matrix = [list(input().strip()) for _ in range(n)]  # получаем сетку в виде списка списков
    # [['#', '.', '#'], ['.', '#', '.'], ['#', '.', '#']]
    # print(grid_matrix)

    islands = 0  # общее количество островов
    max_size = 0  # самый большой остров

    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # возможные направления-ребра в которых может передвигаться курсор в момент изучения клетки матрицы

    # (2) --- основная логика, проходим по всем ячейкам матрицы
    for i in range(n):  # по строкам
        for j in range(m):  # по столбцам
            if grid_matrix[i][j] == '#':  # если это символ земли, значит будем изучать остров

                # (3) --- Запускаем обход в ширину
                # нужно изведать остров от этой точки-ячейки.
                islands += 1  # раз вступили на край острова - засчитываем его
                size = 0  # раз мы тут не были, значит остров неизведан и размер его 0
                queue = deque([(i, j)])  #  создаем объект дека и кладем в него координаты новой земли (в виде списка с кортежем)
                grid_matrix[i][j] = '.'  # помечаем как посещённое (символ воды, такие тоже есть в матрице изначально, но нам они не интересны)

                # запускаем цикл проверки состояния дека, пока там есть элементы
                # до тех пор, пока будут находиться смежные земли острова, очередь будет пополняться
                while queue:

                    # (3.1) --- выдергиваем элемент слева очереди
                    x, y = queue.popleft()
                    size += 1  # считаем его размер, как просто размер ячейки

                    # (3.2) --- начинаем кружить по возможным направлениям движения курсора
                    for dx, dy in directions:
                        nx, ny = x + dx, y + dy  # получаем новые координаты возможного шага
                        if 0 <= nx < n and 0 <= ny < m and grid_matrix[nx][ny] == '#':  # если в указанном направлении продолжение текущего острова
                            grid_matrix[nx][ny] = '.'  # помечаем как посещенную ячейку
                            queue.append((nx, ny))  # добавляем в конец дека

                # актуализируем максимальный размер острова
                if size > max_size:
                    max_size = size

            # если символ воды или воды (т.к. эту ячейку уже посетили), то пропускаем ее

    print(islands, max_size)

if __name__ == "__main__":
    find_islads()