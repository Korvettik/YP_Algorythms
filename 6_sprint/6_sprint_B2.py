#  https://contest.yandex.ru/contest/25070/run-report/154131879/

# -- ПРИНЦИП РАБОТЫ ---
"""
1) Получаем данные. Карту земли и воды представляем в виде списка списков - матрицы, сетки. Задаем начальные нулевые
значения искомых величин. Сразу создаем список кортежей  - возможных шагов перемещения курсора в рамках одного острова (вверх, вниз, влево, вправо)
2) Основным циклом итеративно идем по всем ячейкам сверху вниз, слева направо. Если ячейка является землей - это представляет для нас интерес. Ячейки с водой пропускаются.
3) Если ячейка с землей, то увеличиваем счетчик количества островов, т.к. это первый остров, что нам встретился.
Теперь нужно понять его размеры и замерить их. Для этого используем DFS (обход в глубину) как вспомогательную функцию,
начиная с текущей точки земли.
4) Обходя точки одного острова будем помечать в общей матрице как исследованные, т.е. водой - чтобы выйдя из этого цикла, порожденного первой точкой,
перейти к новой точке основного итеративного цикла, которая также может оказаться землей, а значит новым островом. С ним нужно проделать такую же операцию изучения.
5) Дойдя до последней ячейки матрицы, выходим из нее и выводим результат. Количество островов есть количество групп точек, которые между
собой являются смежными, но никак не связаны друг с другом. Размер наибольшей группы обновляется.
"""

# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Реализуется проход по всем ячейкам, которые представляют интерес - # земля. Ячейки с водой . игнорируются. Этим символом также 
помечаются те ячейки, что мы уже посещали.
Вокруг каждой ячейки исследуется ее окружение через вспомогательную функцию dfs, которая посещает все смежные ячейки - участки земли.
"""

# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность - O(n * m), так как нужно посетить каждую ячейку матрицы-сетки.
Пространственная сложность - O(n * m), так как нужно хранить значения каждой ячейки.
"""

from collections import deque

def find_islads():
    # (1) --- ввод данных
    n, m = map(int, input().split())
    grid_matrix = [list(input().strip()) for _ in range(n)]
    # [['#', '.', '#'], ['.', '#', '.'], ['#', '.', '#']]

    islands = 0  # общее количество островов
    max_size = 0  # самый большой остров


    # (2) --- основная логика, проходим по всем ячейкам матрицы
    for i in range(n):
        for j in range(m):
            if grid_matrix[i][j] == '#':

                # (3) --- запускаем обход отсрова
                islands += 1
                size = dfs(grid_matrix, i, j, n, m)

                # актуализируем максимальный размер острова
                if size > max_size:
                    max_size = size

            # если символ воды или воды (т.к. эту ячейку уже посетили), то пропускаем ее

    print(islands, max_size)




def dfs(grid_matrix, i, j, n, m):
    "Функция для обхода острова от заданных координат i, j"

    queue = deque([(i, j)])
    size = 0

    while queue:
        i, j = queue.popleft()

        if i < 0 or i >= n or j < 0 or j >= m or grid_matrix[i][j] != '#':
            continue

        grid_matrix[i][j] = '.'

        size += 1

        # directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        # посещаем соседние ячейки в 4 направлениях
        queue.append((i + 1, j))
        queue.append((i - 1, j))
        queue.append((i, j + 1))
        queue.append((i, j - 1))

    return size

if __name__ == "__main__":
    find_islads()