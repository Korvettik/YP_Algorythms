# https://contest.yandex.ru/contest/26133/run-report/155594423/


# -- ПРИНЦИП РАБОТЫ ---
"""
В соответствии с условием задачи, формат входных строк записывается и интерпретируется так

abc ---- просто строчные буквы
2[ab] ----  abab
3[a]2[r2[t]] ---- aaa + rttrtt ----- aaarttrtt
2[a2[b]] ----- abbabb

1) Сначала распакуем все полученные строки в память (расшифруем их).
Вот так распакуем каждую строку в полный ее вид:
Для этого идем по полученным символам строки.
Если буква, то добавляем ее к текущей строке (изначально пустая строка).
Если цифра, собираем всё число.
Если  [ , то кладём текущую строку и число в стек, начинаем новую строку.
Если ] , то берем из стека (prev_string, repeat_count), делаем current_string = prev_string + current_string * repeat_count.



2) Ищем наибольший общий префикс
Берём первую строку как образец.
Для каждого символа по порядку проверяем, совпадает ли он во всех строках.
Как только находим несовпадение или конец одной из строк — останавливаемся.

"""



# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Так как по условию задачи, количество символов в итоговых строках не более 10*5, то уместно все строки сразу расшифровать и загрузить в память.
Так как требуется найти префикс. то сравниваем посимвольно все строки, начиная с первого символа самой короткой строки.
"""



# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность - O(n), где n есть длина самой длинной строки и вдруг она полностью совпадает со всеми остальными.
Пространственная сложность - O(n), где n суммарное количество символов всех строк
"""

def unpack(s):
    stack = []  # каждый элемент: (prev_string, repeat_count)
    current_str = ""
    i = 0
    while i < len(s):
        if s[i].isdigit():
            num = 0
            while i < len(s) and s[i].isdigit():
                num = num * 10 + int(s[i])
                i += 1
            # s[i] == '['
            stack.append((current_str, num))
            current_str = ""
            i += 1
        elif s[i] == ']':
            prev_str, repeat = stack.pop()
            current_str = prev_str + current_str * repeat
            i += 1
        else:  # буква
            current_str += s[i]
            i += 1
    return current_str



if __name__ == "__main__":
    n = int(input())  # число строк

    # получаем строки в исходном зашифрованном виде
    strings = [input().strip() for _ in range(n)]

    # предварительно распаковывам
    unpacked = [unpack(s) for s in strings]




    # основная логика

    if not unpacked:  # базовый случай, вдруг ничего нет
        print("")

    prefix = []
    min_len = min(len(s) for s in unpacked)

    for i in range(min_len):  # по индексам самой короткой строки
        char = unpacked[0][i]
        if all(s[i] == char for s in unpacked):
            prefix.append(char)
        else:
            break

    print("".join(prefix))
