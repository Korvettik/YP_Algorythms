# https://contest.yandex.ru/contest/26133/run-report/156180173/


# -- ПРИНЦИП РАБОТЫ ---
"""
В соответствии с условием задачи, формат входных строк записывается и интерпретируется так

abc ---- просто строчные буквы
2[ab] ----  abab
3[a]2[r2[t]] ---- aaa + rttrtt ----- aaarttrtt
2[a2[b]] ----- abbabb

1) Сначала получим и распакуем первую строку в память (расшифруем ее).

Логика распаковки и перевод строки в полный ее вид:
Для этого идем по полученным символам строки.
Если буква, то добавляем ее к текущей строке (изначально пустая строка).
Если цифра, собираем всё число.
Если  [ , то кладём текущую строку и число в стек, начинаем новую строку.
Если ] , то берем из стека (prev_string, repeat_count), делаем current_string = prev_string + current_string * repeat_count.

2) Первоя строка фактически приравнивается к самому первому возможному префиксу
3) Затем получим и распакуем вторую строку
4) Ищем наибольший общий префикс между существующим префиксом и данной строкой

Логика поиска общего префикса:
Для каждого символа по порядку проверяем, совпадает ли он между известным префиксом и текущей строкой.
Как только находим несовпадение или конец одной из строк — останавливаемся.

5) Обновляем префикс и так делаем для всех вводимых строк
6) Выводим итоговый префикс.

"""



# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Храним только текущий префикс и текущую распакованную строку.
"""



# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность - O(L * n), где L распаковка каждой строки, n количество строк.
Пространственная сложность - O(m + l),где m длина текущего префикса, l длина текущей распакованной строки
"""

def unpack(s):
    """
    делает расшифровку-распаковку закодированной строки
    """
    stack = []  # каждый элемент: (prev_string, repeat_count)
    current_str = ''
    i = 0
    while i < len(s):
        if s[i].isdigit():
            num = 0
            while i < len(s) and s[i].isdigit():
                num = num * 10 + int(s[i])
                i += 1
            # s[i] == '['
            stack.append((current_str, num))
            current_str = ""
            i += 1
        elif s[i] == ']':
            prev_str, repeat = stack.pop()
            current_str = prev_str + current_str * repeat
            i += 1
        else:  # буква
            current_str += s[i]
            i += 1
    return current_str



def find_common_prefix(first, second) -> str:
    """находит общий префикс двух строк"""
    i = 0
    while i < len(first) and i < len(second) and first[i] == second[i]:
        i += 1
    return first[:i]



if __name__ == "__main__":
    n = int(input())  # число строк

    if n == 0:
        print("")  # вдруг, ничего нет
    else:
        # читаем и распаковываем первую строку
        first_encoded = input().strip()
        current_prefix = unpack(first_encoded)

        # далее остальные строки
        for _ in range(n - 1):

            next_encoded = input().strip()
            next_unpacked = unpack(next_encoded)

            # обновляем префикс до общего с новой строкой
            current_prefix = find_common_prefix(current_prefix, next_unpacked)

            # случай, если вдруг префикс стал пустым, дальше можно не проверять
            if not current_prefix:
                break

        print(current_prefix)
