# https://contest.yandex.ru/contest/26133/run-report/155601058/



# -- ПРИНЦИП РАБОТЫ ---
"""
Идея такая --- возможно ли дойти от начала строки до конца, используя как шаги (или перепрыгивания) длину слов из набора возможных слов.
Используем подход префиксного дерева для формирования скоростного прохода по словам и принцип динамического программирования как основной логики.

1) Сначала строим префиксное дерево.
Т.е. от узла с пустого-корня начинаем формировать цепочки слов, где по движению цепочки используются общие буквы в общем порядке

2) По индексам от длины строки создадим список, где значения будут True или False состояния на данном индексе. --- dp список
dp[0] = True (пустая строка считается разбиваемой, т.е. пустота и все остальное) - это базовый случай

2) Теперь будем смотреть,
dp[i] — можно ли разбить префикс длины i строки text на слова из словаря.
Для этого начнем движение по буквам подаваемого текста. И будем проверять от корня наличие узлов с такими же буквами. Если буквы соответствуют узлам дерева, идем дальше по цепочке дерева.
Если узел с буквой соответствует целому завершенному слову, то помечаем dp[i] = True этой буквы (т.е. до этого все непрерывно и корректно разбивалось).
Далее берется следующая буква слова и также цепочка от него (с пропусками идем до узла его) проверяется на завершенность целого слова.

3) Если в конце концов именно последняя буква будет в значении True, значит каким-то образом удалось дойти до нее так, что вся виртуальная цепочка слов была построена без разрывов (от одного слова к другому,).
Если нет, то нет. Ответ будет в dp[n].

"""



# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Исходную строку храним сразу в памяти, т.к. по условию задачи она не длиннее 10*5 символов.
Для скорости используем префиксное дерево, где все слова уже отсортированы. А для логики работы динамическое программирование.
"""



# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность:
Построить префиксное дерево --- O(m*l) где m количество слов набора. l их длина
Проход по самому тексту --- O(n*i)  где n длина текста. i максимальная глубина дерева
Итого O(m*l + n*i)

Пространственная сложность:
 O(s + n) --- где s сумма длин всех слов, n длина текста (списка dp)
"""




class TrieNode:
    """Узел для дерева"""
    def __init__(self):
        self.children = {}
        self.is_end = False


def can_separate(text, words):
    n = len(text)
    dp = [False] * (n + 1)
    dp[0] = True  # пустая строка

    # строим префиксное дерево
    root = TrieNode()  # корень пустота
    for word in words:
        node = root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True


    for i in range(n):

        if not dp[i]:
            continue

        else: # если в позицию можно попасть, то от нее можно делать шаги

            # идем по префиксному дереву
            node = root
            j = i
            while j < n and text[j] in node.children:
                node = node.children[text[j]]
                j += 1
                if node.is_end:
                    dp[j] = True

    return dp[n]




if __name__ == "__main__":
    t = input().strip()  # текст, который нужно разбить на слова
    n = int(input())  # число допустимых к использованию слов
    # получаем допустимые слова
    words = [input().strip() for _ in range(n)]

    if can_separate(t, words):
        print("YES")
    else:
        print("NO")