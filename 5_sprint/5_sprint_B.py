# https://contest.yandex.ru/contest/24810/run-report/152003736/

# -- ПРИНЦИП РАБОТЫ ---
"""

          5
    /          \
   1           10
   /\         /  \
     3       8
     /\      /\
    2       6
   /\      /\

Представляем нашу функцию удаления как рекурсивную. Внутри нее организуем поиск таким образом,
что мы сравниваем подаваемый искомый ключ с текущим значением узла. Свойство бинарного дерева говорит,
что дочерний элемент больше родительского узла располагается по правому ребру, а меньший - по левому.
Соответственно, если нужно пойти по ребрам и искать в детях, то мы заново переопределяем ссылку на дочерний элемент,
но внутри него также рекурсивно запускаем функцию удаления. Т.е. мы как-бы изменяем поддерево, если там будет удален
нужный элемент. И первый заход в рекурсию вернет текущи корень дерева - т.е. либо что и подавали (но далее внутри дерево
будет изменено), либо новый корень (куда рекурсия вернется обратным ходом).
В случае, если искомый удаляемый элемент нельзя отнести ни к левому ни к правому поддереву, это значит,
что, либо мы сейчас находимся на нем (искомом) и его надо удалить, либо его нет.
Если его нет (базовый случай рекурсии) - рекурсия начинает возвращаться обратным ходом. Если есть, то нужно удалить
данный узел. Под удалением понимаем исключение данного узла из структуры бинарного дерева, т.е. ни родительское ребро,
ни дочернее от него не будут вести на этот узел, а будут соединены. Т.е. поддерево видоизменится.
Тут может быть несколько вариантов. Если у удаляемого узла только какой-то один из детей - левый или правый, то на
место удаляемого узла мы подсоединяем другой.
Причем вариант, если и другого также нет, обрабатывается автоматически - там None, а это базовый случай.
Если же есть оба ребенка, а по условию задачи нужно при удалении найденного узла вырезать его и при этом
сохранить бинарное дерево. Для этого найдем самый маленький элемент из правого поддерева и изменим значение
найденного узла на значение минимального (ссылки между объектами при этом останутся, изменится только значение).
Минимальный по значению элемент (а теперь новый переименованный по значению корень вместо удаленного) будет точно
меньше корня этого поддерева, но при этом больше левого поддерева.
Для этого перейдем в правое поддерево удаляемого узла, и будем искать элемент только по его левым ребрам до тех пор, пока
не будет найден последний существующий левый элемент.
Теперь нам нужно удалить этот самый минимальный элемент. Аналогично, как в самом начале, рекурсивно запустим поиск
и удаление этого элемента, зная, что он был последним по левым веткам правого поддерева и за ним уже ничего нет.
Рекурсия дойдет до None в его детях, а там на базовом случае пойдет назад - т.е. ссылка на найденный элемент
заменится на None его детей.
"""

# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Руководствуемся свойством бинарного дерева. Движемся по ярусам, выбирая левое или правое  ребро. 
В соответствии с условием задачи - по высоте дерева.

"""


# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Сложность алгоритма соответствует требуемой сложности - O(h), где h –— высота дерева.
Т.е. удалится ровно тот элемент (если он есть) ровно на том ярусе дерева, где будет обнаружен. 
Так как дерево бинарное, то мы движемся по нужному ребру левому или правому и на соответствующем ярусе ищем нужный элемент.

Пространственная сложность О(n), где n - количество элементов, куда мы опускаемся в рекурсии по ярусам бинарного дерева.
"""








from typing import Optional
import os

LOCAL = os.environ.get('REMOTE_JUDGE', 'false') != 'true'

if LOCAL:
    class Node:
        def __init__(self, left=None, right=None, value=0):
            self.right = right
            self.left = left
            self.value = value
else:
    from node import Node



# """
#          5
#    /          \
#   1           10
#   /\         /  \
#     3       8
#     /\      /\
#    2       6
#   /\      /\
#
# """



def remove(root, key):

    # Если дерево пустое / конец дерева / узла не нашли
    if root == None:
        return None

    # Ищем узел для удаления
    # Руководствуемся правилом:
    # 1) что ищется текущий корень (нода).
    # 2) элементы больше ноды по правому ребру, меньше ноды - по левому ребру

    if key < root.value:
        root.left = remove(root.left, key)  # рекурсия. пошли искать по левому ребру.
        # Т.е. перезаписываем левое поддерево, т.к. внутри него могут быть изменения
    elif key > root.value:
        root.right = remove(root.right, key)


    else:
        # Нашли узел для удаления (т.е. текущий узел либо тот что ищем, либо его нет - значит ничего не делаем)
        # Удалить искомый элемент - значит нужно откорректировать дерево, т.е. соединить ребра родительского и дочернего узлов так,
        # чтобы удаляемый элемент утратил связь с деревом

        # 1 -- ВАРИАНТ, если из детей кто-то один (левый или правый) --
        if root.left == None:
            return root.right  # заменяем текущий узел на правого ребенка (даже если там None)
            # - рекурсия тут нас возвращает в предыдущую итерацию присваивания root.left = или root.right =
        elif root.right == None:
            return root.left

        # 2 -- ВАРИАНТ, если нет детей --
        # в данном случае, если узел, куда переводится ребро также равен None,
        # то и вернется в предыдущую итерацию присваивания root.left = или root.right = также None
        # (базовый случай, описан в самом начале)

        # 3 -- ВАРИАНТ, если у узла два ребенка --
        # Чтобы соблюсти правило дерева (когда по правому ребру элемент больший,
        # а по левому меньший относительно самого узла), будем выбирать по всем правым ребрам узлов такое,
        # чтобы значение его было минимально в этом поддереве.
        # 1) Все узлы в правом поддереве больше удаляемого узла - новый правый ребенок будет больше родителя
        # 2) Минимальный узел в правом поддереве гарантированно больше всех узлов в левом поддереве удаляемого узла
        # 3) + он меньше всех остальных узлов в правом поддереве

        # Находим минимальный узел в правом поддереве
        min_node = finding_minimum_node(root.right)

        # Заменяем значение текущего узла на значение минимального
        root.value = min_node.value

        # Удаляем минимальный узел из правого поддерева - т.е. дерево обрезается с конца
        root.right = remove(root.right, min_node.value)

    return root  # возвращаем текущую голову измененного (где-то внутри) дерева


def finding_minimum_node(node):
    """Ищем узел с минимальным значением в поддереве"""
    current_node = node

    while current_node.left != None:
        current_node = current_node.left  # наименьшие узлы правого поддерева всегда будут в левых его ребрах

    return current_node







def test():
    node1 = Node(None, None, 2)
    node2 = Node(node1, None, 3)
    node3 = Node(None, node2, 1)
    node4 = Node(None, None, 6)
    node5 = Node(node4, None, 8)
    node6 = Node(node5, None, 10)
    node7 = Node(node3, node6, 5)

    # new_head = remove(node1, 2)
    # assert new_head.value == 2

    new_head = remove(node7, 10)
    print(f'head {new_head.value}')
    assert new_head.value == 5
    print(f'right {new_head.right.value}')
    assert new_head.right is node5
    assert new_head.right.value == 8


if __name__ == '__main__':
    test()