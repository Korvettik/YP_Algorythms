# https://contest.yandex.ru/contest/24810/run-report/150806407/

# -- ПРИНЦИП РАБОТЫ ---
"""
В учебных материалах изложены примеры сортировки кучи по принципу max_heap --- когда в корень дерева выносится элемент с самым большим значением.
Такой вариант рабочий, его и применим.

Общий принцип следующий:
1) Получили данные, сформировали список. Представим, что это неотсортированная куча.
2) Создаем новый список, для будущей отсортированной кучи - пирамиды. Первым элементом записываем None - для дальнейшего удобства работы с индексами.
3) Итеративно перебираем все элементы неотсортированной кучи. Каждый элемент добавляем на те позиции, которые являются дочерними по отношению к корню.
Причем при добавлении сравниваем добавляемый элемент с родительским.
И если есть нарушение величин - исправляем это, меняя их местами.

4) Отсотрированная куча готова
5) Теперь вынимаем корень кучи и помещаем в результирующий список. На место выдернутой головы ставим послений элемент кучи. А заодно и проверяем нового родителя и нового ребенка. При необходимости меняем их местами.
6) Куча закончилась, выводим отсортированный список элементов.
"""


# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --
"""
Применяется метод сортировки max_heap, что гарантирует время выполенения всей сортировки за O(nlog n)
"""


# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность.
Так как по условию задачи нужно использовать бинарное дерево, кучу, то сложность равна гарантированно O(nlog n).
Объясняется тем, что каждый добавляемый элемент нужно обработать - O(n),
и при каждом добавлении нужно текущую кучу привести в правильное состояние, пройтись по родителям и детям от добавлямого элемента - O(log n).
Так как при процессе сортировки также вынимаются элементы и восстанавливается правильное состояние кучи, то там также O(nlog n).
Асимптотически итоговое O(nlog n)

Пространственная сложность.
O(n) - так как мы работаем с текущим деревом и переставляем в нем элементы. Так как для сорттировки выдергиваем элементы в отдельный список, то это тоже O(n).
Асимптотически общая сумма будет O(n).
"""


def heapsort(array):
    # Создадим пустую бинарную кучу.
    heap = [None]  # причем под индексом 0 уже стоит элемент None (не используется)

    # вставляем в неё по одному все элементы массива, сохраняя свойства кучи (используя логику перемещения наверх).
    for item in array:
        heap.append(item)  # вставляется в конец
        index = len(heap) - 1  # получаем индекс этого последнего элемента

        # просеивание вверх (снизу вверх)
        while index > 1:
            parent = index // 2  # узнаем индекс родителя
            # если ребенок БОЛЬШЕ родителя, меняем
            if heap[index] > heap[parent]:
                heap[index], heap[parent] = heap[parent], heap[index]
                index = parent  # поднимаемся дальше по индексу
            else:
                break

    result = []  # создаем результирующий итоговый список, отсортированную кучу

    while len(heap) > 1:
        # берем максимальный элемент кучи (корень) из просеянного вверх списка
        # и помещаем его в итоговый список
        result.append(heap[1])  # добавление в конец


        # восстанавливаем свойства кучи, чтобы корень ее снова стал самым большим элементом

        # в предыдущем списке заменяем изъятый корень последним элементом (последний вырезается)
        if len(heap) > 2:
            heap[1] = heap.pop()
        else:
            heap.pop()  # последний элемент просто вырезаем
            break

        # Просеивание вниз
        index = 1  # берем индекс вот этого самого последнего элемента (он теперь в начале)
        while True:
            left = 2 * index  # индекс левого ребенка
            right = 2 * index + 1  # индекс правого ребенка
            largest = index  # по умолчанию предположим, что родитель и есть индекс с элементом наибольшего значения

            # Находим наибольшего из родителя и детей
            if left < len(heap) and heap[left] > heap[largest]:
                largest = left
            if right < len(heap) and heap[right] > heap[largest]:
                largest = right

            # Если родитель уже наибольший - выходим
            if largest == index:
                break

            # Меняем родителя с наибольшим ребенком
            heap[index], heap[largest] = heap[largest], heap[index]
            index = largest

    return result









def main():
    n = int(input().strip())  # число участников

    user_list = list()  # список с участниками

    for user in range(n):
        user_name, user_score, user_penalty = input().strip().split()  # читаем параметры пользователя
        # записываем в виде кортежа информацию о каждом пользователе

        # сравниваться будут кортежи
        user_list.append((-int(user_score), int(user_penalty), user_name))  # записываем в виде кортежа информацию о каждом пользователе


    # print(user_list)
    # print(sorted(user_list))


    # запуск.
    sorted_user_list = heapsort(user_list)


    # Вывод отсортированного массива.
    for user in sorted_user_list[::-1]:
        print(user[2])




if __name__ == '__main__':
    main()