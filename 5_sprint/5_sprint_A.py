#

# -- ПРИНЦИП РАБОТЫ ---



# -- ДОКАЗАТЕЛЬСТВА КОРРЕКТНОСТИ --



# -- ОПРЕДЕЛЕНИЕ СЛОЖНОСТИ АЛГОРИТМА --
"""
Временная сложность.
Так как по условию задачи нужно использовать бинарное дерево, кучу, то сложность равна гарантированно O(nlog n).
Объясняется тем, что каждый добавляемый элемент нужно обработать - O(n),
и при каждом добавлении нужно текущую кучу привести в правильное состояние, пройтись по родителям и детям от добавлямого элемента - O(log n).
Так как при процессе сортировки также вынимаются элементы и восстанавливается правильное состояние кучи, то там также O(nlog n).
Асимптотически итоговое O(nlog n)

Пространственная сложность.
O(n) - так как мы работаем с текущим деревом и переставляем в нем элементы. Так как для сорттировки выдергиваем элементы в отдельный список, то это тоже O(n).
Асимптотически общая сумма будет O(n).
"""


def heapsort(array):
    # Создадим пустую бинарную кучу.
    heap = [None]  # причем под индексом 0 уже стоит элемент None (не используется)

    # Вставим в неё по одному все элементы массива, сохраняя свойства кучи (используя логику перемещения наверх).
    for item in array:
        heap_add(heap, item)

    # Бинарное дерево построено

    # Будем извлекать из него наиболее приоритетные элементы, удаляя их из кучи.
    sortedArray = []  # итоговый список отсортированных элементов
    while len(heap) > 1:
        max_val = pop_max(heap)  # из бинарного дерева вырезали корень, как самый большой элемент
        sortedArray.append(max_val)

    return sortedArray



def heap_add(heap, key):
    """
    Добавление элемента в кучу.
    1) Добавляем в конец списка.
    2) Затем запускаем логику перемещения его наверх (при необходимости)
    """
    heap.append(key)
    index = len(heap)-1  # если это единственный первый нужный элемент, то индекс 0 - None(не используется), 1 - текущий добавленный

    shift_up(heap, index)  # запускаем проверку (логику перемещения вверх)


def shift_up(heap, index):
    """
    Логика перемещения наверх.
    heap - работаем с текущей кучей + новый добавленный элемент
    index - указывает на последний добавленный элемент, который возможно нужно будет переместить наверх
    """
    #print(f'index {index}')

    # базовый случай для рекурсии
    if index == 1:  #  в куче всего [None, текущий добавленный], т.е. всего 1 элемент. Его не с чем сравнивать и перемещать.
        return

    # добавился второй элемент [None, <первый уже был>, текущий добавленный]
    parent_index = index // 2  # по формуле находим индекс родительского элемента (это <первый уже был>), чтобы сравнить с ним текущий добавленный элемент
    #print(f'parent_index {parent_index}')

    if heap[index] > heap[parent_index]:  # сравниваются кортежи
        heap[index], heap[parent_index] = heap[parent_index], heap[index]  # меняем местами, чтобы значение родителя было больше значения ребенка

        shift_up(heap, parent_index)  # рекурсивно поднимаемся вверх по дереву и наводим порядок - родитель должен быть больше ребенка




def pop_max(heap):
    """
    Из текущего бинарного дерева вынимаем самый максимальный элемент
     """

    result = heap[1]  # [None, вот его вынимаем, второй, третий ...] - т.е. корень
    heap[1] = heap[len(heap) - 1]  # на его место ставим просто последний элемент
    heap.pop()  # c конца удалили последний

    shift_down(heap, 1)  # восстанавливаем бинарное дерево - запускаем проверку (логику перемещения вниз), индекс тут всегда один

    return result



def shift_down(heap, index):
    """
    Логика перемещения вниз.
    heap - работаем с текущей кучей
    index - указывает на ее голову, которую нужно проверить, что она действительно больше своих детей
    """

    heap_max_index = len(heap)-1  # получаем последний индекс кучи-дерева
    left = index*2  # по формуле определяем индекс левого ребенка
    right = index*2+1  # по формуле определяем индекс правого ребенка

    # базовый случай - нет дочерних узлов (число левого индекса предполагаемого ребенка > реального возможного индекса ---- т.е. его не может быть)
    if left > heap_max_index:
        return

    # выбираем по ребенку индекс - ветку, в направлении которой пойдем. Т.е. если конкретный ребенок больше родителя
    if right <= heap_max_index and heap[right] > heap[left]:  # если индекс справа существует + значение правого ребенка больше левого
        index_largest = right # идем в правую ветку
    else:
        index_largest = left  # идем в левую ветку

    # если значение элемента под индексом ребенка больше значения родителя, то меняем их местами
    if heap[index_largest] > heap[index]:
        heap[index_largest], heap[index] = heap[index], heap[index_largest]

        shift_down(heap, index_largest) # рекурсивно опускаемся вниз по дереву и наводим порядок - родитель должен быть больше ребенка.
        # Передаем вершину ранее выбранного дерева (а значение его выше мы уже поменяли)












if __name__ == '__main__':

    if __name__ == '__main__':
        n = int(input().strip())  # число участников

        user_list = list()  # список с участниками

        for user in range(n):
            user_name, user_score, user_penalty = input().strip().split()  # читаем параметры пользователя
            # записываем в виде кортежа информацию о каждом пользователе

            # сравниваться будут кортежи, поэтому немного модифицируем порядок
            user_list.append((-int(user_score), int(user_penalty), user_name))  # записываем в виде кортежа информацию о каждом пользователе


        # print(user_list)
        # print(sorted(user_list))





        # запуск.
        sorted_user_list = heapsort(user_list)





        # Вывод отсортированного массива.
        for user in sorted_user_list[::-1]:
            print(user[2])